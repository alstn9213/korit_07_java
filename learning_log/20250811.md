객체명.getclass() -> 클래스명을 반환하는 메서드. 다만 패키지 경로까지 포함되기 때문에 .getSimpleName()까지 붙인다. 
이처럼 메서드가 연속되는 것을 chaining method라고 한다. 체이닝 메서드를 사용할 경우 return 값의 유형을 명확히 알고있어야 그 다음 어떤 메서드를 호출할 지 알수있다.

break;는 반복문을 즉시 종료하고, return;은 메서드를 즉시 종료하는데, continue;의 경우에는 현재 반복만 종료하고 그 다음 반복문으로 넘어간다.

```java
public static void main(String[] args) {
    System.out.println("---------continue----------");
    for(int i=0;i<10;i++){
        System.out.println(i+1);
    }

    for(int i=0;i<10;i++){
        if((i+1) %2 != 1) {
            System.out.println(i);
        }
    }

    for(int i=0;i<10;i++){
        if((i+1)%2==1){
            continue; // 해당 반복을 종료하고 다음 반복을 실행
        }
        System.out.println(i);
    }
}
     
      
```


# object 클래스
- 모든 클래스는 Object 클래스를 상속받는다. 그래서 interface를 implement할 때나 다른 서브 클래스를 만들어서 extends 명령어를 입력했을때
직접 만들었던 고유 메서드 외에 toString 메서드가 있었다.
    1. toString() : 클래스 이름과 해시코드(일종의 주소지)를 return함.
        - 이를 override해서 클래스의 정보를 출력할 때 사용함.
        - ObjectTest / ObjectTestMain 클래스 작성
        - 필드를 정의하고, toString() 메서드를 override해서 필요한 필드를 출력함 -> main단계에서 특정 객체의 특정 필드를 객체의 이름만으로 출력이 가능함(toString()을 직접 쓸 필요없이 객체 이름 뒤에 자동으로 추가된다.)
    2. equals() : 두 객체가 '논리적으로 같은지'를 비교하는 메서드(주소지의 차이가 아니라). 기본적으로 Object 클래스의 equals()메서드는 두 객체의 참조 주소를 비교한다.
        - 형식 : 객체명1.equals(객체명2) -> 객체명1과 객체명2의 참조 주소가 동일한지 확인함.
    3. hashCode() : 객체를 정수값(해시값)으로 변환(16진수가 아니라). 해시값은 주로 해시 기반 컬렉션에서 사용된다.
        - equals() 메서드를 재정의하게 되면 반드시 hashCode() 메서드도 재정의 해야만 한다. 왜냐하면 동일한 객체(equals == true)는 동일한 해시 코드를 가져야하기 때문인데,
       문제는 해시코드가 같다고 해서 eqauls()가 true가 아닌 경우가 있다.

# Lombok
ctrl + alt + s(설정) -> 플러그인 -> Lombok 설치
disabled/비활성화라고 나와있으면 활성화된 상태라는 뜻.

chrome -> maven repositories로 들어가서 lombok검색 -> 웬만하면 최신버전
그리고 빌드시스템이 gradle이기때문에(그리고 코틀린이 아니기때문에), groovy short로 복사 
```
dependencies {
    implementation 'org.projectlombok:lombok:1.18.38'
    annotationProcessor 'org.projectlombok:lombok:1.18.38'
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'

}
```

# lombok 주요 annotation
1. @Getter/ @setter
    - class level에 작성할 경우 getter/setter 메서드를 자동생성.
    - field level에 작성할 경우 해당 필드에만 생성
    - 주의 : 객체마다 다른 값을 갖는 비정형(non-static) 필드에 대해서만 적용됨. 
```java
@Setter
@Getter
public class Person{
    private String name;
    private int age;
}
     
```

2. @ToString
    - toString() 메서드를 자동으로 생성. 다만 재정의가 안되기 때문에 override method(alt +ins)를 쓰는 경우가 많다.

3. @EqualsAndHashCode
   - equals() / hashCode() 메서드를 자동생성, 객체의 동일성 비교 로직을 구현할 때 사용
        - equals()를 재정의하면 hashCode()도 같이 재정의해야하기 때문에 애너케이션도 세트로 묶여있다.

4. @NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor
    - @NoArgsConstructor : argument가 없는 기본 생성자 생성
    - @RequiredArgsConstructor : final 또는 '@NonNull' 애너테이션이 붙은 필드만 필수적으로 요구하는 매개변수 생성자를 생성
    - @AllArgsConstructor : 모든 필드를 argument로 요구하는 매개변수 생성자
```java
@NoArgsConstructor
@RequiredArgsConstructor
@AllArgsConstructor
public class Person{
    @NonNull // 필수적인 생성자 매개변수
    private String name;
    private int age;
    
}
public class PersonMain{
    public static void main(String[] args) {
        Person person1 = new Person(); 
        Person person2 = new Person("김이"); 
        Person person3 = new Person("김삼", 20);
        
    }
}
```

4. @Data
    - @Getter / @Setter / @ToString / @EqualsAndHashCode / @RequiredArgsConstructor가 들어가 있는 종합 패키지 애너테이션.
   
```java
@Entity
@Data
@NoArgsConstuctor
@AllArgsConstructor
public class Student extends Person {
    
}
```

5. @Builder 

# static

## 정의
- 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
- static으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않음' (해당 클래스의 인스턴스가 전부 동일한 값을 공유한다.)
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분된다.