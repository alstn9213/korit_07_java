# static

## 정의
- 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
- static으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않음' (해당 클래스의 인스턴스가 전부 동일한 값을 공유한다.)
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분된다.

## 특징
1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근한다. 따라서 데이터를 공유하거나 상태를 저장할 때 유용하다.
2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드시 메모리에 할당(객체가 생성될 때가 아니라).

```java
@AllArgsConstructor
public class KoreaItStudent07 extends KoreaItStudent {
//    클래스 변수 선언
    private static String introduction = "코리아 아이티 국비과정 7월";
//    필드정의
    private String name;
    private int age;
    private String address;
//    private String introduction = "코리아 아이티 국비과정 7월";
}
public class Main {
    public static void main(String[] args) {
        KoreaItStudent07 student1 = new KoreaItStudent07("김일", 20, "부산광역시");
    }
}
```
클래스의 인스턴스들은 전부 다 private static String 정적 변수를 가지게 된다. 즉, 어느 클래스의 인스턴스인지 확인하더라도 몇 월 국비생인지 알 수 있다.

3. 인스턴스가 필요없음 : 객체를 생성하지 않고도 클래스명.필드 / 클래스명.메서드명() 형태로 직접 접근이 가능하다.(필드는 private 접근 지정자가 아니어야한다.)
4. 메모리 효율성: static 변수는 프로그램이 종료될 때까지 한번만 메모리에 할당된다.

# Singleton Pattern (싱글톤패턴)
## 정의
소프트웨어 '디자인 패턴' 중 하나로, 어떤 클래스가 '하나의 인스턴스만 갖도록 보장하고', 그 인스턴스에 접근할 수 있는 '전역적인 접근법'을 제공하는 패턴.
예를 들어, 데이터베이스 연결과 같은 리소스는 프로그램 전체에서 하나의 인스턴스만 사용해야 할 때가 많기 때문에 싱글톤 패턴을 사용함.

## 특징
1. 하나의 인스턴스만 존재 : 하나의 인스턴스만 생성되고, 이 인스턴스는 프로그램이 실행되는 동안 유지
2. 전역 접근법 : 싱글톤 인스턴스는 정적 메서드를 통하여 어디서든 접근가능
    -> 객체명.인스턴스명() x / 클래스명.메서드명()
3.  인스턴스의 생명주기 관리 : 클래스 자체가 인스턴스 생성을 관리하므로 다른 객체들이 인스턴스를 생성하거나 폐기할 수 없음.

## 장점
1. 메모리 절약 : 불필요한 인스턴스 생성을 방지하여 메모리 절약가능하다.(static 변수 / 메서드의 장점과 같다)
2. 글로벌(전역적) 접근 : 전역적 접근이 가능하여 메모리 관리가 용이하다, -> 다만 잦은 접근 자체는 단점이다.
3. 일관성 유지 : 애플리케이션 전반에서 하나의 인스턴스만 사용하기때문에 상태일관성을 유지한다.

## 단점
1. 테스트 어려움 : 싱글톤 패턴은 전역적으로 사용되므로 단위(대부분 메서드 단위) 테스트가 어렵다. 
2. 의존성 숨김: 싱글톤을 남용하면 클래스간의 의존성을 추적하기 어려울 수 있다.

보통 싱글톤 패턴을 만들 때 정적 변수이름이 instance다.
static 메서드의 이름 보통 getInstance()

# 빌더패턴(Builder Pattern) 

```java
@AllArgsConstructor
public class Student{
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private String[] subjects;
    private double[] scores;
}

public class StudentMain {
    student student1 = new Student(필드 입력);
}

```

# 빌더패턴이 생기게 된 원인
1. 복잡한 생성자 문제
   - 객체의 필드가 많아질수록 생성자 패러미터 수도 늘어남.
2. 생성자 오버로딩 문제
   - 생성자에 필요한 조합이 다를 경우 많은 생성자들을 일일이 정의해야한다.
   - 유지보수에 악영향 / 필드 하나를 추가하면 생성자를 다 고쳐야한다.
3. 가독성과 유지보수 문제
    - 코드를 작성하고 읽는 입장에서는 객체를 생성할 때 어떤 값이 어떤 필드에 해당하는지 명확하지 않아서 실수를 유발할 수 있음.
```java
public static void main(String[] args) {
    Student student1 = new Student("김일", "김이"); // 김일 학교의 김이 학생인지 김이 학교의 김일 학생인지 모름
}
```

## 정의 
객체의 생성과정에서 '복잡한 생성자'를 대신하여 객체를 '단계적으로 '생성할 수 있도록 도와주는 디자인 패턴 중 생성 관련 파트. GoF(Gang of Four) 디자인 패턴중 하나로
객체 생성시 가독성과 유연성을 제공하는 것이 목표
    - 여기서 유연성의 의미는 생성자에서 필드를 순서대로 채워넣지않고 순서를 바꾸는 것을 의미.

```java
public class Student {
    private String name;
    private String school;
    
    public Student(String name, String school) {
        this.name =name;
        this.school =school;
        
    }
    ublic Student(String school, String name) {
        this.name =name;
        this.school =school;

    }
}
```

## 특징
1. 객체를 생성하는 여러 개의 필드를 '명시적'으로 관리할 수 있음.
2. 불필요한 생성자 오버로딩을 줄여 가독성을 높임
3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성
    
대부분의 메서드는 행위를 나타내기때문에 동사로 시작하지만 Builder패턴의 경우 대입될 필드의 이름과 동일한 메서드명을 짓는다.