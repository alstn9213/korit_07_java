# 예외(Exception)란?
개발자가 예측할 수 있고, 그에 대한 대비를 할 수 있는것들
# 오류(Error)란?
개발자가 예측할 수 있지만 해결할 수 없거나 예측불가능한 것들

다수의 예외는 이미 개발자들이 정의를 해놓았다. 
예외 발생 여부와 관계없이 finally문은 마지막에 실행된다.

# Lambda Expression(람다식)
- java 8에서 도입된 함수형 프로그래밍을 지원하기 위한 표현식

```java
//(매개변수) -> {실행문}

//기존의 익명 클래스방식
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {

            System.out.println("Hello Java!");
        }
    };
    runnable.run(); // Hello Java!
}
```

```java
public static void main(String[] args) {
    Runnable runnable = () -> System.out.println("Hello Java!");
    runnable.run();
}
```
## 람다식의 등장배경
- 람다식이 나오기 전에는 Java에서 함수형 프로그래밍을 하기 위해 익명 클래스를 주로 사용
- 하지만 코드가 길어지고 불필요한 반복이 많아, 가독성이 떨어졌다.(call1 유형의 코드를 5개 정의할 경우 객체명도 다르게 정해야할 것)

```java
import java.util.Comparator;

public static void main(String[] args) {
    Comparator<Integer> comparator = new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1.compareTo(02);
        }
    };
    
    Comparator<Integer> lambdaComparator = (o1, o2) -> o1.compareTo(o2);
}
```

## 람다식 장점
1. 코드 간결화 - 불필요한 코드 제거로(Integer의 반복이 없다.), 가독성 향상
2. 표현력 향상 - 익명 클래스를 짧은 표현으로 대체
3. 지연 연산 - Stream API와 함께 사용시 지연 연산을 통해 성능 최적화

## 람다식 단점
1. 디버깅 어려움 - 람다식 내부에서 발생하는 오류의 디버깅이 어렵다.
2. 재사용성 낮음 - 익명 클래스에 비해 재사용이 어려움
3. 복잡한 로직 표현에 부적합 - 단순 로직의 경우 람다식 사용, 아닌 걍우는 익명 클래스 사용

## 람다식 문법
람다식 구조는 크게 3가지로 나뉜다.
1. 매개변수 목록
2. 화살표(->) : 그래서 JS는 arrow expression 이라고 표현한다.
3. 구현부/실행문

```java
public static void main(String[] args) {
//    1. 매개변수와 실행문이 하나일 때 (중괄호 생략가능)
    (int x, int y) -> x + y // return 생략
//    2. 매개변수가 하나일때 (소괄호 생략가능)
    str -> System.out.println(str);
//    3. 실행문이 여러 줄일 때 (중괄호 필수)
    (x, y) -> {
        int sum = x + y;
        return sum;
    }    
}
```
## 함수형 인터페이스(Functional Interface)
- 람다식은 단일 메서드만 가지는 인터페이스(함수형 인터페이스)를 구현하는 형태로 사용된다. `@FunctionalInterface` 애너테이션을 사용하면
컴파일 시에 단일 메서드인지 체크한다.
- 그래서 `사용자 정의 함수형 인터페이스`를 작성할 때 클래스 레벨에 `@FunctionalInterface`를 명시해 준다.

인터페이스에 있는 메서드는 전부 `추상 메서드`이다. -> implement 하게되면 추상 메서드를 전부 강제로 구현해야만 한다.
하지만 call1() ~ call4()까지의 유형을 하나의 객체에 강제 구현할 경우 call3()만 필요한데 나머지도 정의해야한다는 문제점이 있다.
그래서 각 유형 당 하나의 인터페이스/추상메서드만 존재하게 됐다.

```java
@FunctionalInterface // 메서드가 하나인지 체크하는 애너테이션
interface MyFunction {
    void start();
}

public static void main(String[] args) {
    MyFunction myFunction = () -> System.out.println("정의한 함수를 실행합니다.");
//    매개변수가 아예 없는 경우 ()로 표현한다. 매개변수가 하나면 소괄호 생략.
    myFunction.start();
}
```

## java에서 제겅하는 주요 `함수형 인터페이스`
1. Runnable - void run(); - call1()
2. Consumer - void accept(T t); - call2()
3. Supplier - T get(); - call3()
4. Function<T, R> - R apply(T t); -call4()
5. Predicate - boolean test(T t); - return타입이 boolean으로 고정이라 call()유형으로 묶긴 애매하지만 굳이 따지자면 call4()이다. return true / false중 하나니까.

### 함수형 인터페이스 별 상세
1. Runnable
- 매개변수도 없고, 반환값도 없는 단순 실행을 위한 인터페이스
- 사용처 : 스레드 실행 시, 비동기 작업 실행시
2. Supplier
- 매개변수 없이 값을 반환하는 인터페이스, 단순히 값을 '공급'하는 역할
- 사용처 : 객체 생성, 지연로딩
3. Consumer
- 값을 매개변수로 받아서 사용하고, 아무것도 반환하지 않는 인터페이스, 데이터를 '소비'하는 역할
- 사용처 : 데이터 처리, 로깅, 이벤트 핸들러
4. Function<T, R>
- '하나의 매개변수'받아서 연산을 수행한 후 결과를 리턴함.
- T는 입력타입, R은 리턴타입을 명시함.
- 사용처 : 데이터 변환, 매핑 처리, 컬렉션 조작
5. Predicate
- 하나의 매개변수를 받아서 특정 조건을 검사한 뒤 true/false를 반환
- 사용처 : 필터링, 조건 검사, 유효성 검사
- 특히 Predicate의 경우 true/false 반환값을 가지고 조건문을 돌릴 때 많이 사용한다.
6. 함수형 인터페이스 조합
- java8 에서는 함수형 인터페이스 끼리의 조합이 가능하다.

```java
import java.util.function.Predicate;

public static void main(String[] args) {
//    메서드 1
    Predicate<String> startsWithA = str -> str.startsWith("A"); // .startWith()는 String 클래스에 있는 메서드
//    메서드 2
    Predicate<String> endsWithX  = str -> str.endsWith("X");
    Predicate<String> startsWithAAndEndsWithX  = startsWithA.and(endsWithX);
    System.out.println(startsWithAAndEndsWithX.test("Alex"));
    
    
}
```